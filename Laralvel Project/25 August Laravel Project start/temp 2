Круто, ты правильно объяснил про `public`. Дробим дальше.

# 7A.3 — Dockerfile для PHP-FPM (с нужными расширениями + Composer)

Сейчас просто создаём файл (с комментами в коде), сборку запустим на следующем шаге.

```bash
cd /opt/laravel-blog

# Образ PHP-FPM + расширения, которые типично нужны Laravel-проектам
cat > docker/php/Dockerfile <<'DOCKER'
# База: легкий Alpine с PHP 8.3 FPM
FROM php:8.3-fpm-alpine

# Утилиты, чтобы работать внутри контейнера (composer, git и т.п.)
# + dev-пакеты для сборки PHP-расширений (будут удалены после сборки)
RUN apk add --no-cache \
    bash git curl unzip icu-libs oniguruma libxml2 libzip \
    libpng libjpeg-turbo libwebp freetype \
    && apk add --no-cache --virtual .build-deps \
    build-base icu-dev oniguruma-dev libxml2-dev libzip-dev zlib-dev \
    libpng-dev libjpeg-turbo-dev libwebp-dev freetype-dev

# Сборка и включение расширений: pdo_mysql, mbstring, bcmath, gd, intl, zip и т.д.
RUN docker-php-ext-configure gd --with-freetype --with-jpeg --with-webp \
 && docker-php-ext-install -j"$(nproc)" \
    pdo_mysql mbstring exif pcntl bcmath gd intl zip \
 && apk del --no-network .build-deps   # dev-пакеты больше не нужны

# Устанавливаем Composer (будем выполнять composer install внутри контейнера php)
RUN curl -sS https://getcomposer.org/installer | php \
 && mv composer.phar /usr/local/bin/composer

# Рабочая директория PHP-контейнера — здесь будет смонтирован проект
WORKDIR /var/www/html
DOCKER

# Проверим, что файл на месте
head -n 20 docker/php/Dockerfile
```

**Чек-вопросы:**

1. Видишь строку `FROM php:8.3-fpm-alpine` в выводе `head`?
2. Понимаешь, зачем мы ставим `pdo_mysql` и `intl`? (ответ одним предложением)
3. Почему Composer ставим внутрь образа `php`, а не в `web`?

---

# 7A.4 — `compose.yaml` для web + php + db

Теперь опишем весь стек сразу (с комментариями), а уже затем запустим.

```bash
cd /opt/laravel-blog

cat > compose.yaml <<'YAML'
services:
  web:                                   # Nginx — единственный сервис с наружным портом
    image: nginx:alpine
    ports:
      - "8080:80"                        # хост:8080 -> контейнер:80
    volumes:
      - ./src:/var/www/html:ro           # код монтируем ТОЛЬКО для чтения в nginx
      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf:ro  # наш конфиг (root=/public)
    depends_on:
      php:                               # ждём, пока PHP пройдёт healthcheck
        condition: service_healthy
    restart: unless-stopped

  php:                                   # PHP-FPM — исполняет PHP
    build:
      context: ./docker/php              # используем Dockerfile, который создали выше
      dockerfile: Dockerfile
    volumes:
      - ./src:/var/www/html              # тот же код, но RW (composer, cache, storage)
    healthcheck:
      test: ["CMD", "php", "-v"]         # простой "жив/не жив"
      interval: 10s
      timeout: 3s
      retries: 3
    restart: unless-stopped

  db:                                    # MySQL — только внутренняя сеть
    image: mysql:8.0
    environment:
      MYSQL_DATABASE: laravel            # создаст БД 'laravel'
      MYSQL_USER: laravel                # создаст пользователя 'laravel'
      MYSQL_PASSWORD: laravel            # пароль пользователя
      MYSQL_ROOT_PASSWORD: root          # root пароль
    volumes:
      - db_data:/var/lib/mysql           # данные БД сохраняем в именованный том
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "127.0.0.1", "-proot"]
      interval: 10s
      timeout: 5s
      retries: 10
    restart: unless-stopped

volumes:
  db_data:                               # именованный том (переживёт пересоздание контейнера)
YAML

# Самопроверка синтаксиса и зависимостей
docker compose config
```

Ожидаемо `docker compose config` выведет слитую, валидную конфигурацию без ошибок.

**Чек-вопросы:**

1. Команда `docker compose config` прошла без ошибок?
2. Какой сервис единственный публикует порт наружу и зачем?
3. Почему у `web` монтирование кода `:ro`, а у `php` — без `:ro`?

---

# 7A.5 — Сборка и запуск стека (пока без кода в src)

```bash
cd /opt/laravel-blog
docker compose up -d --build      # соберёт php-образ и поднимет web/php/db
docker compose ps                 # статусы контейнеров
```

Сейчас `src/` пустая → у Nginx корень `/var/www/html/public`, которого нет → главная страница даст **404** — это НОРМАЛЬНО на этом шаге.

Проверка:

```bash
curl -sI http://127.0.0.1:8080/ | head -n1   # вероятно, '404 Not Found'
```

**Чек-вопросы:**

1. В `docker compose ps` все три сервиса в состоянии `running` (а `php` и `db` не `exited`)?
2. Что вернул `curl -sI ...` и почему это ожидаемо?
3. Если `php` вдруг не `healthy`, где быстро посмотреть логи только этого сервиса?

---

Скажи ответы на вопросы и покажи коротко вывод `docker compose ps`. После этого перейдём к 7B: **подключим сам код Laravel (GitHub), настроим `.env`, выполним `composer install` и миграции — всё через `docker compose exec php ...`**.
