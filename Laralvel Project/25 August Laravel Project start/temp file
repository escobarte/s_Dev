Отлично, всё сделаем **только через Docker Compose**. Пойдём маленькими шагами.

## Шаг 7A — каркас стека (web + php + db) через Compose

Создадим папки и файлы (всё с комментариями прямо в коде), поднимем пустой стек — без проекта ещё.

Выполни на `10.100.93.7`:

```bash
# 1) Структура проекта
mkdir -p /opt/laravel-blog/{src,nginx,docker/php}
cd /opt/laravel-blog

# 2) compose.yaml — весь стек управляем одной командой
cat > compose.yaml <<'YAML'
services:
  web:                                   # Nginx — единственный сервис, видимый снаружи
    image: nginx:alpine                  # лёгкий nginx
    ports:
      - "8080:80"                        # публикуем 80 порт контейнера на 8080 хоста
    volumes:
      - ./src:/var/www/html:ro           # код монтируем ТОЛЬКО для чтения в nginx
      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf:ro  # наш конфиг
    depends_on:
      php:                               # ждём готовности PHP-FPM
        condition: service_healthy
    restart: unless-stopped

  php:                                   # PHP-FPM — исполняет PHP-код
    build:                               # собираем свой образ, чтобы поставить расширения + composer
      context: ./docker/php
      dockerfile: Dockerfile
    volumes:
      - ./src:/var/www/html              # тот же код, но с правом записи (composer, cache, storage)
    healthcheck:
      test: ["CMD", "php", "-v"]         # простая проверка "PHP доступен"
      interval: 10s
      timeout: 3s
      retries: 3
    restart: unless-stopped

  db:                                    # MySQL — база ТОЛЬКО во внутренней сети
    image: mysql:8.0
    environment:
      MYSQL_DATABASE: laravel            # имя БД
      MYSQL_USER: laravel                # пользователь
      MYSQL_PASSWORD: laravel            # пароль
      MYSQL_ROOT_PASSWORD: root          # root пароль
    volumes:
      - db_data:/var/lib/mysql           # данные БД сохраняем вне контейнера
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "127.0.0.1", "-proot"]
      interval: 10s
      timeout: 5s
      retries: 10
    restart: unless-stopped

volumes:
  db_data:                               # именованный том для БД
YAML

# 3) Конфиг Nginx — корень строго /public (как требует Laravel)
cat > nginx/default.conf <<'NGINX'
server {
  listen 80;
  server_name _;

  root /var/www/html/public;                 # наружу показываем ТОЛЬКО public/
  index index.php index.html;

  location / {
    try_files $uri $uri/ /index.php?$query_string;  # нет файла? отправляем в index.php
  }

  location ~ \.php$ {
    include        /etc/nginx/fastcgi_params;
    fastcgi_param  SCRIPT_FILENAME $document_root$fastcgi_script_name;
    fastcgi_pass   php:9000;                        # имя сервиса php (внутренняя сеть Compose)
    fastcgi_index  index.php;
  }
}
NGINX

# 4) Dockerfile для PHP — ставим нужные расширения + composer
cat > docker/php/Dockerfile <<'DOCKER'
FROM php:8.3-fpm-alpine

# Базовые пакеты и dev-зависимости для сборки расширений
RUN apk add --no-cache \
    bash git curl unzip libpng libjpeg-turbo libwebp freetype icu-libs \
    oniguruma libxml2 libzip \
    libpng-dev libjpeg-turbo-dev libwebp-dev freetype-dev icu-dev oniguruma-dev \
    libxml2-dev libzip-dev zlib-dev shadow

# Собираем и включаем популярные расширения, нужные Laravel-проектам
RUN docker-php-ext-configure gd --with-freetype --with-jpeg --with-webp \
 && docker-php-ext-install -j$(nproc) \
    pdo_mysql mbstring exif pcntl bcmath gd intl zip

# Ставим Composer в контейнер PHP (чтобы всё делать через docker compose exec php …)
RUN curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer

WORKDIR /var/www/html
DOCKER

# 5) Соберём образы и поднимем «пустой» стек (без кода — это ок)
docker compose up -d --build

# 6) Проверка статуса
docker compose ps
```

Ожидание сейчас: в `docker compose ps` должны быть **три сервиса** (`web`, `php`, `db`), и у `php`/`db` состояние не «exited».
(Страница на 8080 пока 404 — кода Laravel ещё нет, это нормально.)

**Чек-вопрос (один):** `docker compose ps` у тебя показывает три сервиса без ошибок? (Да/Нет)
